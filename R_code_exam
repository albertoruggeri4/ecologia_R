# ESAME DI ECOLOGIA DEL PAESAGGIO (DUCCIO ROCCHINI - UNIBO)
# R CODE


### INDICE
# 1. R_code_primocod.r   
# 2. R_code_spatial.r   
# 3. R_code_spatial2.r
# 4. R_code_point_patterns.r  
# 5. R_code_teleril.r   
# 6. R_code_landcover.r   
# 7. R_code_multitemp.r   
# 8. R_code_multitemp_NO2.r   
# 9. R_code_snow.r   
# 10. R_code_patches.r  
# 11. R_code_crop.r
# 12. R_code_sdm.r
  

#########################################################################
#########################################################################

### 1. R_CODE_PRIMOCOD.R

# AR - IMPORTIAMO IL PACCHETTO "SP" ATTRAVERSO LA FUNZIONE LIBRARY - UTILE PER L'ANALISI SPAZIALE DEI DATI
# AR - PER INSTALLARE UN PACKAGE -> install.packages("name_packages")
# AR - LE VIRGOLETTE VENGONO UTILIZZATE OGNI VOLTA CHE ANDIAMO FUORI R

install.packages("sp")
library (sp)


# AR - COME VISUALIZZARE UN DATA SET

data(meuse) # UTILIZZIAMO LA FUNZIONE DATA() PER VISUALIZZARE IL DATA SET MEUSE
meuse # TUTTE LE INFORMAZIONI
head (meuse) # SOLO I PRIMI 6 ELEMENTI DEL DATASET
name (meuse) # NOMI DELLE VARIABILI
summary (meuse) #INFORMAZIONI COME MEDIA, VAL MIN E MAX

# AR - FUNZIONE pairs() CREA UN GRAFICO DI CORRELAZIONE TRA LE VARIABILI DEL DATA SET INSERITO COME ARGOMENTO
pairs (meuse)

# AR - SE SI VUOLE VISUALLIZARE SOLO ALCUNE VARIABILI CON LA FUNZIONE pairs()
# AR - OCCORRE UTILIZZARE LA TILDE (~), AGGIUNGERE LE VARIABILI DI INTERESSE CONCATENATE DAL "+"
# AR - ED INFINE INSERIRE IL DATA SET DI INTERESSE data = ""
pairs(~ cadmium + copper + lead , data = meuse)


# AR - ESERCIZIO: utilizza la funzione pairs mettendo cadium, copper, leaad e zinc
pairs(~ cadmium + copper + lead + zinc, data = meuse)

# AR - PER PRENDERE UN SUBSET SI FA RICORSO ALLO "SLICING": si utlizzano le parentesi quadre "[]", inserendo gli indici delle variabili di interesse, partendo da (",") colonna 3 a colonna 6(":"). Ci darà grafico uguale a prima
pairs(meuse[,3:6])

# AR - PER CAMBIARE COLOREALLE FUNZIONI: col = "color_name"  (lista colori visualizzabile nella documentation R)
pairs(meuse[,3:6], col="blue")

# AR - PER CAMBIARE TIPO DI CARATTERI UTILIZZO pch (point character), ogni numero corrisponde ad un simbolo (visualizzabili sulla documentazione R)
pairs(meuse[,3:6], col="blue", pch=17)

# AR - PER CAMBIARE DIMENSIONE PUNTI USO cex("character exageration"),se cex=1 non cambia nulla
pairs(meuse[,3:6], col="blue", pch=17, cex=3)

# AR - PER INSERIRO UN TITOLO AL GRAFICO: main="titolo"
pairs(meuse[,3:6], col="blue", pch=17, cex=3, main="Primo pairs")


#ESERCIZIO inserire la variabile elevation
pairs(meuse[,3:7], col="blue", pch=17, cex=3, main="Primo pairs")

# FUNZIONE PER INSERIRE FILE DALL'ESTERNO
panel.correlations <- function(x, y, digits=1, prefix="", cex.cor)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(0, 1, 0, 1))
    r1=cor(x,y,use="pairwise.complete.obs")
    r <- abs(cor(x, y,use="pairwise.complete.obs"))

 

    txt <- format(c(r1, 0.123456789), digits=digits)[1]
    txt <- paste(prefix, txt, sep="")
    if(missing(cex.cor)) cex <- 0.9/strwidth(txt)
    text(0.5, 0.5, txt, cex = cex * r)
}

 

panel.smoothing <- function (x, y, col = par("col"), bg = NA, pch = par("pch"),
    cex = 1, col.smooth = "red", span = 2/3, iter = 3, ...)
{
    points(x, y, pch = pch, col = col, bg = bg, cex = cex)
    ok <- is.finite(x) & is.finite(y)
    if (any(ok))
        lines(stats::lowess(x[ok], y[ok], f = span, iter = iter),
            col = 1, ...)
}

 


panel.histograms <- function(x, ...)
{
    usr <- par("usr"); on.exit(par(usr))
    par(usr = c(usr[1:2], 0, 1.5) )
    h <- hist(x, plot = FALSE)
    breaks <- h$breaks; nB <- length(breaks)
    y <- h$counts; y <- y/max(y)
    rect(breaks[-nB], 0, breaks[-1], y, col="white", ...)
}

# AR - LA FUNZIONE "lowess" è smooter locale: uso linea per mostrare relazione tra variabili
# AR - LA FUNZIONE "histograms" fa istogramma variabili
# AR - LA FUNZIONE "lower.panel" è parte inferiore del grafico pairs e decido cosa metterci, ad es. le correlazioni
# AR - LA FUNZIONE "upper.panel" è parte superiore e ci metto lo smoothing, ossia il grafico dei punti con le linee di correlazione
# AR - LA FUNZIONE "diag.panel" è diagonale e ci metto gli istogrammi

pairs(meuse[,3:6], lower.panel = panel.correlations, upper.panel = panel.smoothing, diag.panel = panel.histograms)

#Esercizio. mettere nel lower lo smoothing e nell'upper le correlation
pairs(meuse[,3:6], lower.panel = panel.smoothing, upper.panel = panel.correlations, diag.panel = panel.histograms)

# AR - UTILIZZIAMO IL SEGNO $ PER SPECIFICARE IL DATA SET DELLA VARIABILE SELEZIONATA dataset$variabile
plot(meuse$cadmium, meuse$copper)

#AR - POSSIAMO IN ALTERNATIVA, STABILIRE TRAMITE ATTACH() IL DATA SET DI RIFERIMENTO
attach(meuse)
plot(cadmium, copper)

# AR - CAMBIO NOME ETICHETTE: xlab e ylab cambiano il nome alle variabili
plot(cadmium, copper, pch=19, col="green", main="Primo plot", xlab="cadmio", ylab="rame")

# AR - PROVIAMO AD ESAGERARE I CARATTERI ATTRAVERO cex.lab
plot(cadmium, copper, pch=19, col="green", main="Primo plot", xlab="cadmio", ylab="rame", cex.lab=1.5, cex=2)

###########################################
###########################################
###########################################


##### 2. R_CODE_SPATIAL.R


# AR - R spaziale: funzioni spaziali in Ecologia del paesaggio



#install.packajes("sp")

# AR - RICHIAMO IL PACCHETTO SP
library(sp)


data(meuse)

meuse

head(meuse)

# AR - PLOTTIAMO CADMIUM E LEAD

# AR - alleghiamo il dataframe
attach(meuse)

plot(cadmium,lead,col="red",pch=19, cex=0.5)

#  AR - ESERCIZIO plot di copper e zinco con simbolo triangolo (17) e colore verde
plot(copper,zin,col="green",pch=17,cex=2)

# AR - CAMBIARE ETICHETTE
plot(copper,zin,col="green",pch=17,cex=2, xlab= "rame", ylab ='zinco')

# AR - FUNZIONE par(mfrow=(n°righe,n°colonne)) PER CREARE UN MULTIFRAME(mf) O MULTIPANEL/ numeri in riga con virgola sono vettori, 1 riga e 2 colonne
par(mfrow=c(1,2))
plot(cadmium,lead,col="red",pch=19, cex=2)
plot(copper,zinc,col="green",pch=17,cex=2)

# AR - PER INVERTIRE I GRAFICI
par(mfrow=c(2,1))
plot(cadmium,lead,col="red",pch=19, cex=2)
plot(copper,zinc,col="green",pch=17,cex=2)


## AR - NUOVA LIBRERIA GGally --> he R package 'ggplot2' is a plotting system based on the grammar of graphics. 'GGally' extends 'ggplot2' by adding several functions to reduce the complexity of combining geometric objects with transformed data. Some of these functions include a pairwise plot matrix, a two group pairwise plot matrix, a parallel coordinates plot, a survival plot, and several functions to plot networks.
install.packages("GGally")
library(GGally)

# AR - per fare un subset utilizziamo la parentesi quadra, vediamo sull'head. la , significa partiamo da
ggpairs(meuse[,3:6])

# AR -  Spatial!! LA FUNZIONE COORDINATES --> OTTENERE LE COORDINATE DEL DATASET
head(meuse)
coordinates(meuse)=~x+y
plot(meuse)

# AR - POSSIAMO CREARE UN SPPLOT PER CAPIRI I DATI RELATIVI ALLO ZINCO, IN PARTICOLARE LA COMPOSIZIONE CHIMICA DI QUESTO FIUME
spplot(meuse,"zinc")


# AR - OSSERVARE LA CONCENTRAZIONE SIA PER LO ZINCO VISTA PRECEDENTEMENTE ED ORA PER IL RAME SULLA PARTE SX DEL FIUME
spplot(meuse,"copper")

# AR - UTILIZZIAMO LA FUNZIONE bubble() PER CREARE UN BUBBLE PLOT, (sempre sul pacchetto sp)
bubble(meuse,"zinc")

# AR - ESERCIZIO: INSERIRE I DATI RELATIVI A DUE CASI STUDIO: Foraminiferi (Sofia), carbon capture (Marco)
# AR - CREIAMO UN ARRAY
foram <- c(10, 20, 35, 55, 67, 80)
carbon <- c(5, 15, 30, 70, 85, 99)

# AR - PLOTTIAMO I DATI PER VALUTARE LE CORRELAZIONI
plot(foram, carbon, col="green",pch=1)

####  AR - PORTIAMO DEI DALL'ESTERNO SUL COVID-19
# AR - SETTIAMO LA WORKING DIRECTORY
setwd("C:/Lab")

# AR -FUNZIONE read.table("") PER LEGGERE UNA TABELLA, FILE CSV, ECC
read.table("covid_agg.csv",header=TRUE)

# ASSOCIARE LA TABELLA AD UN NOME EX."covid"
# AR - LEGGIAMO LA TABELLA, SE C'è IL TITOLO SI METTE HEAD= T/TRUE o al contrario F/FALSE
covid <- read.table("covid_agg.csv", head= TRUE)

##############################################
##############################################
##############################################

### 4. R CODE POINTS PATTERNS.R
# AR - Codici per analisi dei patterns


setwd("C:/Lab")

covid <- read.table("covid_agg.csv", head=T)

head(covid)

plot(covid$country, covid$cases)

#  AR - CAMBIARE POSIZIOE ETICHETTE : Con las =0 è di default e rimangono paralleli

plot(covid$country, covid$cases, las=0) #etichette X e Y parallele
plot(covid$country, covid$cases, las=1) #etichette Y orizzontali
plot(covid$country, covid$cases, las=2) #Etichette perpendicolari
plot(covid$country, covid$cases, las=3) #Etichette 

# AR - PER MODIFICARE LA DIMENSIONE DEL CARATTERE
plot(covid$country, covid$cases, las=2, cex.axis= 0.7)

# AR - INSERIAMO DUE NUOVE LIBRARY UTILI PER L'ANALISI SPAZIALE
install.packages("ggplot2")
install.packages("spatstat")

library("ggplot2")
library("spatstat")

# AR - UTILIZZIAMO IL DATA SET "mpg" CONTENUTO ALL'INTERNO DEL PACCHETTO "ggplot2"
# AR - IL DATA SET "mpg" CONTIENE DATI RELATIVI AL RISPARMIO DI CARBURANTE NEGLI ANNI 1999 E 2008 PER 38 MODELLI DI AUTO POPOLARI
data("mpg")
head("mpg")

# AR - UTILIZZANDO LA FUNZIONE GGPLOT E' POSSIBILE GENERARE UN GRAFICO I CUI PARAMETRI SONO:
# AR - MAPPATURA aes() (aesthetic)
# AR - GEOMETRIA (geom) DELLE VARIABILI (ex. geom_line/point/polygon)

# AR - ggplot con i dati mpg
ggplot(mpg,aes(x=displ,y=hwy)) + geom_point()
ggplot(mpg,aes(x=displ,y=hwy)) + geom_line()  
# AR - funzione utilizzata per le variazioni di temperatura
ggplot(mpg,aes(x=displ,y=hwy)) + geom_polygon()

# AR - ggplot con i dati covid-19
ggplot(covid,aes(x=lon,y=lat,size=cases)) + geom_point()

# AR - ANDIAMO A CREARE LA MAPPA DELLA DENSITA'
# AR - create dataset for spatstat, c per i vettori/range in questo caso della long e lat
attach(covid) #in modo da allegare il nostro dataset con anche lon e lat
covids <- ppp(lon, lat, c(-180,180), c(-90,90))

# AR - CALCOLIAMO LA DENSITA' DEI PUNTI COVID TRAMITE LA FUNZONE density()  E L'ASSOCIAMO AD UN NOME "d"
d <- density(covids)
plot(d) #andiamo a plottare la densità che abbiamo chiamato d

points(covids) #se si vuol aggiungere il pch


# AR - SALVARE L'.Rdata

# AR - CHIUDERE R E PROVARE A RIAPRIRE Rdata



########## SECONDA PARTE 


# AR - RICHIAMARE LA CARTELLA DI LAVORO (Lab)
setwd("C:/Lab")
load("covid.RData")
ls()

# AR -  RICHIAMARE IL PACCHETTO "spatstat"
library(spatstat)
plot(d)


#  AR - ANDIAMO A CREARE una colorRampPalette() PER GENERARE UNA SCALA DI COLORI
#  AR - INSERIRE UN ARRAY DI COLORI COME ARGOMENTO DELLA FUNZIONE colorRampPalette()
#  AR - IL NUMERO FUORI DALLA FUNZIONE INDICA LA VARIAZIONE DI SFUMATURE TRA UN COLORE E L'ALTRO   
#  AR - ANDIAMO AD INSERIRE LA NOSTRA COLORPALETTE SU COL=
cl <- colorRampPalette(c('yellow','orange','red')) (100)
plot(d, col=cl)

#  AR -  ESERCIZIO: plot della mappa della densità da verde a blu
cl2 <- colorRampPalette(c('green','blue')) (200)
plot(d, col=cl2)

points(covids)

#  AR - PER POTER CARICARE UNO SHAPEFILE ESRI SI UTILIZZA readOGR()
#  AR - IMPORTIAMO IN QUESTO CASO LE LINEE DELLE COSTE 
#  AR -  ASSEGNARE LA FUNZIONE readOGR() A "coastlines"
#  AR -  add=TRUE PER AGGIUNGERE IL NUOVO PLOT ALLO STESSO GRAFICO 
library(rgdal)
coastlines <- readOGR("ne_10m_coastline.shp")
plot(coastlines, add=TRUE)

#  AR -  ESERCIZIO: plot della mappa di densità con una nuova colorazione e aggiunta delle coastlines
cl3 <- colorRampPalette(c('green','yellow','red')) (200)
plot(d, col=cl3)
points(covids)
plot(coastlines, add=TRUE)

#  AR -  ESERCIZIO2: caricare in R il workspace covid.RData (funzione load("...")) e creare una mappa di densità

setwd("C:/Lab")
load("covid.RData")
ls()
library(spatstat)
plot(d, main="densità covid-19")
points(covids)

#  AR -  INSERIRE GLI SHAPEFILE DELLE COSTE
library(rgdal)
coastlines <- readOGR("ne_10m_coastline.shp")
plot(coastlines, add=TRUE)

#   AR - INTERPOLAZIONE DEI PUNTI COVID-19
#  AR -  FUNZIONE marks() PER ESTRARRE O MODIFICARE I SIMBOLI ASSEGNATI AD UN DETERMINAT DATA SET DI UN POINT PATTERN
head(covid)
marks(covids) <- covid$cases
s <- Smooth(covids)
plot(s)

#  AR -  ESERCIZIO: plottare covids con una diversa color palette (punti e shapefile delle coste)
cl5 <- colorRampPalette(c('cyan', 'purple', 'red')) (200) 
plot(s, col=cl5, main="stima dei casi covid-19")
points(covids)
plot(coastlines, add=T)
#   AR - FUNZIONE text() PER VISUALIZZARE IL VALORE DEI PUNTI SULLA MAPPA
text(covids)

###   AR - MAPPA FINALE 
par(mfrow=c(2,1))

#  AR -  DENSITA'
cl5 <- colorRampPalette(c('cyan', 'purple', 'red')) (200) 
plot(d, col=cl5, main="densità covid-19")
points(covids)
coastlines <- readOGR("ne_10m_coastline.shp")
plot(coastlines, add=T)

#  AR -  INTERPOLAZIONE NUMERO DI CASI
cl5 <- colorRampPalette(c('cyan', 'purple', 'red')) (200) 
plot(s, col=cl5, main="stima dei casi")
points(covids)
coastlines <- readOGR("ne_10m_coastline.shp")
plot(coastlines, add=T)

###   AR - DATI SAN MARINO (caso di studio)

setwd("C:/Lab")
library(spatstat)
# CARICARE "Tesi.RData"
load("Tesi.RData")
ls()
head(Tesi)
attach(Tesi)

summary(Tesi)
#   AR - x varia da 12.42 a 12.46
#   AR - y varia da 43.91 a 43.94

#  AR -  POINT PATTERN : x, y, z
Tesippp <- ppp(Longitude, Latitude, c(12.41,12.47), c(43.90,43.95))

#  AR -  DENSITA'
dT <- density(Tesippp)
plot(dT)
points(Tesippp)

dev.off()

############ TERZA PARTE
    
setwd("C:/Lab")
load("Tesi.RData")
ls()
#   AR - OTTENGO I FILE PRESENTI:
#   AR - "dT" è density map di Tesippp
#   AR - "Tesi" è un dataset
#   AR - "Tesippp" è il point pattern del file "Tesi" (da libreria "Spatstat")

#   AR - ASSOCIAMO I VALORI CHE VOGLIAMO STIMARE
library(spatstat)
plot(dT)
points(Tesippp, col="green")

#   AR - ANDIAMO A STIMARE LA RICCHEZZA SPECIFICA
#   AR - CON head() VEDO CHE SI TROVA SOTTO A "Species_richness"
#   AR - FUNZIONE marks() PRENDE I VALORI DELLA TABELLA E LI ASSOCIA AI PUNTI DEL PPP
head(Tesi)
marks(Tesippp) <- Tesi$Species_richness

#   AR - ASSOCIARE LA FUNZIONE Smooth() A "interpol"
interpol <- Smooth(Tesippp)

#   AR - DATI SAN MARINO 
    
library(rgdal)
sanmarino <- readOGR("San_Marino.shp")
plot(sanmarino)
plot(interpol, add=T) 
points(Tesippp,col="green")
#   AR - MAPPA VA A SOVRAPPORSI AI CONFINI DI SAN MARINO 
plot(sanmarino, add=T) 

#   AR - ESERCIZIO: plot multiframe di densità e interpolazione
par(mfrow=c(2,1))
plot(dT, main="Densità di punti")
points(Tesippp, col="green")
plot(interpol, main="Stima della ricchezza di specie")
points(Tesippp, col="green")

#   AR - ESERCIZIO2: inverto la disposizione del grafico
par(mfrow=c(1,2))
plot(dT, main="Densità di punti")
points(Tesippp, col="green")
plot(interpol, main="Stima della ricchezza di specie")
points(Tesippp, col="green")

dev.off()

##############################################
##############################################
##############################################


##### 5. R_CODE_TELERIV

#   AR - CODICE R PER L'ANALISI DI IMMAGINI SATELLITARI
    
#   AR -  PACCHETTI UTILIZZATI: "raster", "RStoolbox"

# install.packages("raster")
# install.packages("RStoolbox")
library(raster)
library(RStoolbox)

setwd("C:/Lab")

#   AR -  FUNZIONE brick() PER IMPORTARE DATI DALL'ESTERNO E ASSOCIARLI AD UNA CERTA IMMAGINE
#   AR - BRICK --> IMPORTA TUTTE LE BANDE // RASTER --> SOLO UNA BANDA
p224r63_2011 <- brick("p224r63_2011_masked.grd")
plot(p224r63_2011)

# B1: blue
# B2: green
# B3: red
# B4: near infrared (nir)
# B5: medium infrared
# B6: thermal infrared
# B7: medium infrared

#  AR -  SALVARE L'.RData

#  AR -  FUNZIONE load("") PER RICARICARE L'.RData
load("teleril.RData")
ls()


plot(p224r63_2011)

cl <- colorRampPalette(c('black','grey','light grey'))(100) 
plot(p224r63_2011, col=cl)
    
#  AR -  ESERCIZIO: plottare l'immagine con una palette differente
clb <- colorRampPalette(c('dark blue','blue','light blue'))(100) 

#   AR - NOTE: la funzione attach(dataframe) non è utilizzabile con il pacchetto raster
#  AR -  "$" LEGA LA COLONNA (LA BANDA) AL DATASET (IMMAGINE SATELLITARE) (es. p224r63$B1_sre)
plot(p224r63_2011$B1_sre, col=clb)

#ESERCIZIO: plottare la banda del NIR con colorRampPalette che varia dal rosso all'arancione al giallo
clnir <- colorRampPalette(c('red','orange','yellow'))(100)
plot(p224r63_2011$B4_sre, col=clnir)

#   AR - MULTIFRAME con 4 bande (blu, rosso, verde, nir(
par(mfrow=c(2,2))
# blue
clb <- colorRampPalette(c('dark blue','blue','light blue'))(100) # 
plot(p224r63_2011$B1_sre, col=clb)
# green
clg <- colorRampPalette(c('dark green','green','light green'))(100) # 
plot(p224r63_2011$B1_sre, col=clg)
# red
clr <- colorRampPalette(c('dark red','red','pink'))(100) # 
plot(p224r63_2011$B1_sre, col=clr)
# nir
clnir <- colorRampPalette(c('red','orange','yellow'))(100)
plot(p224r63_2011$B4_sre, col=clnir)

dev.off()

#   AR - NATURAL COLOR:
#  AR -  tre bande: R= banda del rosso, G= banda del verde, B= banda del blu
plotRGB(p224r63_2011, r=3, g=2, b=1) # plotRGB: no!

#  AR -  STRETCH DEI COLORI CON TIPOLOGIA Lineare ("Lin")
plotRGB(p224r63_2011, r=3, g=2, b=1, stretch="Lin")

#   AR - FALSE COLOR (andiamo ad introdurre la banda nir, non visibile ad occhio nudo)
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")

#   AR - FUNZIONE pdf""() PER SALVARE L'IMMAGINE IN PDF
pdf("primo_grafico")
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")

dev.off()
    
par(mfrow=c(2,1))
plotRGB(p224r63_2011, r=3, g=2, b=1, stretch="Lin")
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")

#   AR - ESERCIZIO: nir nella componente green
plotRGB(p224r63_2011, r=3, g=4, b=2, stretch="Lin")
#   AR - ESERCIZIO2: nir nella componente blue
plotRGB(p224r63_2011, r=3, g=2, b=4, stretch="Lin")


### GIORNO 2

setwd("C:/Lab") 

library(raster)
load("teleril.RData")
ls()

p224r63_1988 <- brick("p224r63_1988_masked.grd")
plot(p224r63_1988)

    
# B1: blue
# B2: green
# B3: red
# B4: near infrared (nir)
# B5: medium infrared
# B6: thermal infrared
# B7: medium infrared

par(mfrow=c(2,2))
# blue
clb <- colorRampPalette(c('dark blue','blue','light blue'))(100) # 
plot(p224r63_1988$B1_sre, col=clb)
# green
clg <- colorRampPalette(c('dark green','green','light green'))(100) # 
plot(p224r63_1988$B1_sre, col=clg)
# red
clr <- colorRampPalette(c('dark red','red','pink'))(100) # 
plot(p224r63_1988$B1_sre, col=clr)
# nir
clnir <- colorRampPalette(c('red','orange','yellow'))(100)
plot(p224r63_1988$B4_sre, col=clnir)


dev.off()

    
# B1: blue - 1
# B2: green - 2
# B3: red - 3
# B4: near infrared (nir) - 4

# NATURAL COLOR
# tre componenti: R G B
# tre bande: R= banda del rosso, G= banda del verde, B= banda del blu
plotRGB(p224r63_1988, r=3, g=2, b=1)
plotRGB(p224r63_1988, r=3, g=2, b=1, stretch="Lin")

#   AR - ESERCIZIO: plottare l'immagine usando il sensore nir al posto della componente r nello spazio RGB
plotRGB(p224r63_1988, r=4, g=3, b=2, stretch="Lin")

#   AR - PLOTTARE LE IMMAGINI DEL 1988 E DEL 2011 PER ANALIZZARE I CAMBIAMENTI
par(mfrow=c(2,1))
plotRGB(p224r63_1988, r=4, g=3, b=2, stretch="Lin")
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")

dev.off()

#  AR -  SPECTRAL INDICES
#  AR -  dvi1988 = nir1988 - red1988
dvi1988 <- p224r63_1988$B4_sre - p224r63_1988$B3_sre

plot(dvi1988)
#   AR - ESERCIZIO: plottare l'indice dvi per il 2011
#   AR - dvi2011 = nir2011 - red2011
dvi2011 <- p224r63_2011$B4_sre - p224r63_2011$B3_sre

plot(dvi2011)

dev.off()

cldvi <- colorRampPalette(c('light blue','light green','green'))(100) 
plot(dvi2011, col=cldvi)

#   AR - MULTITEMPORAL ANALYSIS
difdvi <- dvi2011 - dvi1988
plot(difdvi)

cldifdvi <- colorRampPalette(c('red','white','blue'))(100)  
plot(difdvi, col=cldifdvi)

dev.off()

#  AR -  VISUALIZZARE GLI OUTPUTS
#  AR -  multiframe 1988rgb, 2011rgb, difdvi
par(mfrow=c(3,1))
plotRGB(p224r63_1988, r=4, g=3, b=2, stretch="Lin")
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")
plot(difdvi, col=cldifdvi)

dev.off()

#  AR -  RICAMPIONARE L'IMMAGINE DEL 2011
p224r63_2011lr <- aggregate(p224r63_2011, fact=10)


par(mfrow=c(2,1))
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")
plotRGB(p224r63_2011lr, r=4, g=3, b=2, stretch="Lin")
dev.off()

#   AR - LOWER RESOLUTION
p224r63_2011lr50 <- aggregate(p224r63_2011, fact=50)
# original 30m <- resampled 1500m 

#   AR - PLOT DELLE TRE IMMAGINI CON RISOLUZIONI DIVERSE
par(mfrow=c(3,1))
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")
plotRGB(p224r63_2011lr, r=4, g=3, b=2, stretch="Lin")
plotRGB(p224r63_2011lr50, r=4, g=3, b=2, stretch="Lin")

dev.off()
    
#   AR - CALCOLARE IL dvi2011lr50
dvi2011lr50 <- p224r63_2011lr50$B4_sre - p224r63_2011lr50$B3_sre
plot(dvi2011lr50)

dev.off()

#  AR -  RICAMPIONARE L'IMMAGINE DEL 1988
p224r63_1988lr50 <- aggregate(p224r63_1988, fact=50)

#   AR - CALCOLARE IL dvi1988lr50
dvi1988lr50 <- p224r63_1988lr50$B4_sre - p224r63_1988lr50$B3_sre
plot(dvi1988lr50)

#  AR -  multitemporal analysis lr50 (low resolution)
difdvilr50 <- dvi2011lr50 - dvi1988lr50
plot(difdvilr50)

plot(difdvilr50,col=cldifdvi)

dev.off()

#   AR - PLOTTARE LA difdvi (ad alta definizione) CON LA difdvilr50 (a bassa risoluzione)
par(mfrow=c(2,1))
plot(difdvi, col=cldifdvi)
plot(difdvilr50, col=cldifdvi)
    
dev.off()

##############################################
##############################################
##############################################

### 6. R CODE LAND COVER

# ANALISI LAND COVER

setwd("C:/Lab")

library(raster)
library(RStoolbox)

# AR - Funzione che si chiama brick (impila tutti i dati e importali dentro R). Si utilizzano le virgolette perchè usciamo da R
# AR - p = path r= row dell'immagine landsat scaricata (sud America)
p224r63_2011 <- brick ("p224r63_2011_masked.grd")

# AR - facciamo un plot veloce con le componenti RGB e prima utilizziamo il pacchetto RStoolbox)
# AR - bande di landsat: 1b, 2g, 3r, 4nir
# AR - in questo modo quello che riflette l'infrarosso lo vediamo in ROSSO con r=4
library(RStoolbox)
plotRGB(p224r63_2011, r=4, g=3, b=2, stretch="Lin")

# AR - decidiamo di mettere 4 classi, uno agricolo/nudo, uno di vegetazione, uno di vegetazione separativa
# AR - questa funzione la chiamiamo con il nome dell'immagine ma con una c per dire classificato
p224r63_2011c <- unsuperClass(p224r63_2011, nClasses=4)

p224r63_2011c #così vediamo tutte le informazioni del raster. (att. $map il $ indica che c'è stata un'unione)

# AR - adesso per plottare la mappa
plot(p224r63_2011c$map)

# AR - per stabilire noi una leggenda, colorRampPalette
clclass <- colorRampPalette(c('red', 'green', 'blue', 'black'))(100)
# AR - per riplottarlo
plot(p224r63_2011c$map, col=clclass)


# AR - rifacciamo lo stesso processo, ma con numero classi ridotto
p224r63_2011c <- unsuperClass(p224r63_2011, nClasses=2)
plot(p224r63_2011c$map)

# AR - in funzione del numero di classi, aumenta l'incertezza dell'algoritmo automatico
# AR - Con 2 classi l'incertezza è più bassa che con 4

#######################################################################
#######################################################################
#######################################################################


# 7. R_code_multitemp

# AR - Classificare un'immagine partendo dai dati dei pixel iniziali, raggruppandoli in classi di copertura del suolo
#una classificazione con un algoritmo


library(raster)
library(ncdf4)
library(rgdal)
library(RStoolbox) # per utilizzare la classificazione unsuperClass

setwd("C:/Lab")

cl <- colorRampPalette(c('darkblue','blue','light blue'))(100) 

# AR - IMPORTARE LE IMMAGINI DALLA CARTELLA DI LAVORO (Lab)
defor1 <- brick("C:/Lab/defor1_.jpg") 
defor2 <- brick("C:/Lab/defor2_.jpg") 

# AR - PER USARE DUE CLASSI NON SUPERVISIONATE (ossia non spieghiamo al computer la divisione)
# AR - NOTE: Computer raggruppa pixel che sembrano simili tra lorodefor1_c <- unsuperClass(defor1, nClasses=2)
plot(defor1_c$map)

# AR - ESERCIZIO: classificare con due classi l'immagine satellitare defor
defor2_c <- unsuperClass(defor2, nClasses=2)
plot(defor2_c$map)

par(mfrow=c(2,2))
cl <- colorRampPalette(c('black','green'))(100) # 
plotRGB(defor1,1,2,3)
plotRGB(defor2,1,2,3)
plot(defor1_c$map,col=cl)
plot(defor2_c$map,col=cl)

d1 <- defor1_c$map
d2 <- defor2_c$map


# AR - FUNZIONE freq() PER VISUALIZZARE LA SUDDIVISIONE DEI PIXEL NELLE CLASSI
freq(d1)
totd1 <- 33757+307535 #numero px carta
percent1 <- freq(d1)*100/totd1 # PER CALCOLARE LE PROPORZIONI, LA PERCENTUALE DELLE FREQUENZE

# AR - percentuali:
# AR - aree altre: 10.4
# AR - foreste: 89.6

# AR - STESSO PROCEDIMENTO PER LA CARTA 2
freq(d2)
totd2 <- 164271+178455
percent2 <- freq(d2)*100/totd2
percent2

# AR - aree altre: 48
# AR - foreste: 52


# AR - CREARE UN DATAFRAME CON QUESTI DATI
cover <- c("Agriculture","Forest")
before <- c(9.9,90.1)
after <- c(48.1,52.2)

output <- data.frame(cover,before,after)
View(output)


############# GIORNO 2 ##################
    
library(gridExtra)

setwd("C:/Lab/") # windows

# AR - caricare l'area di lavoro 
load("defor.RData")
ls()
library(raster)
 
# AR -  plottare le due mappe 
par(mfrow=c(1,2))
cl <- colorRampPalette(c('black','green'))(100)
plot(d1c$map, col=cl)
plot(d2c$map, col=cl)

#  AR - copertura 
cover <- c("Agriculture","Forest")
before <- c(10.9,89.1)
after <- c(48.2,51.8)

output <- data.frame(cover,before,after)
output

# AR -  richiamare la libreria ggplot2
library(ggplot2)

#  AR - istogramma della % di copertura prima della deforestazione
ggplot(output, aes(x=cover, y=before, color=cover)) +
geom_bar(stat="identity", fill="white")

dev.off()

#  AR - Exercise: fare lo stesso procedimento per il dopo deforestazione ("after") 
ggplot(output, aes(x=cover, y=after, color=cover)) +
geom_bar(stat="identity", fill="white")

#  AR - assegnare un nome agli istogrammi 
grafico1 <- ggplot(output, aes(x=cover, y=before, color=cover)) +
geom_bar(stat="identity", fill="white")

grafico2 <- ggplot(output, aes(x=cover, y=after, color=cover)) +
geom_bar(stat="identity", fill="white")

#  AR - Exercise: utilizzare la funzione grid.arrange(plot1, plot2, nrow=n) per unire i due grafici
grid.arrange(grafico1, grafico2, nrow=1)

##############################################
##############################################
##############################################

# 8. R_CODE_MULTITEMP 

# AR - Sentinel image about no2 before and after covid in Italy
 

setwd("C:/Lab")

library (raster)
library(ncdf4)


# AR - Exercise: importare tutte le altre immagini EN 
# AR - possibile utilizzare anche un "ciclo for" che importa automaticamente le immagini richieste
EN01 <- raster("EN_0001.png")
EN02 <- raster("EN_0002.png")
EN03 <- raster("EN_0003.png")
EN04 <- raster("EN_0004.png")
EN05 <- raster("EN_0005.png")
EN06 <- raster("EN_0006.png")
EN07 <- raster("EN_0007.png")
EN08 <- raster("EN_0008.png")
EN09 <- raster("EN_0009.png")
EN10 <- raster("EN_0010.png")
EN11 <- raster("EN_0011.png")
EN12 <- raster("EN_0012.png")
EN13 <- raster("EN_0013.png")

# AR - per introdurre una palette di colori 
cl <- colorRampPalette(c('red','orange','yellow'))(100) 

# AR - per plottare l'immagine iniziale (EN01) e l'immagine finale (EN13)
par(mfrow=c(1,2))
plot(EN01, col=cl)
plot(EN13, col=cl)

dev.off()

# AR - differenza fra EN13 ed EN01
difno2 <- EN13 - EN01
cldif <- colorRampPalette(c('blue','black','yellow'))(100) #
plot(difno2, col=cldif)

# AR - per plottare tutte le immagini
par(mfrow=c(4,4))
plot(EN01, col=cl)
plot(EN02, col=cl)
plot(EN03, col=cl)
plot(EN04, col=cl)
plot(EN05, col=cl)
plot(EN06, col=cl)
plot(EN07, col=cl)
plot(EN08, col=cl)
plot(EN09, col=cl)
plot(EN10, col=cl)
plot(EN11, col=cl)
plot(EN12, col=cl)
plot(EN13, col=cl)


##### GIORNO 2 #####

# AR  entrare nella cartella EN all'interno della cartella Lab
setwd("C:/Lab/EN")

###   lapply   ###
# AR - create a list of files (function list.files -- the common pattern is EN)
rlist <- list.files(pattern="EN")

rlist # AR - for see what you have in your list

# AR - con lappy che praticamente non fa altro che applicare una serie di comandi a tutti gli elementi, la funzione è raster, la lista è rlist
import <- lapply(rlist, raster)
# AR - with the raster function i take only one band! The original files are RGB. The value is correlated to px value 0-255 

# AR - then we will make a stack of all images (raster stack), different layer all togethere
EN <- stack(import)

# AR - now we can simply plot the no2 multitemp
cl <- colorRampPalette(c('darkblue','light blue','yellow','orange','red'))(100)
plot(EN, col=cl)


# AR - difference map
dif <- EN$EN_0013 - EN$EN_0001
cld <- colorRampPalette(c('blue','white','red'))(100) #red=high difference
plot(dif, col=cld)


####  AR - box plot #####
# AR -   https://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/boxplot
### AR - statistical analysis with "box plot" (moda, media, mediana)
boxplot(EN) 
# AR - horizontal boxplot
boxplot(EN, horizontal=TRUE)
# AR - outlayer removed
boxplot(EN, horizontal=TRUE,outline=F)

# AR - from the first to the top image there is a negative sponencial degrees about NO2
# AR - NOT IN THE MEDIAN VALUES, BUT IN THE MAXIMUN VALUE


##################################################################
##################################################################
##################################################################

# 9. R_CODE_SNOW

# AR - CODICE R PER ANALISI MULTITEMPORALE DELLA SNOW COVER ATTRAVERSO LE IMMAGGINI DEL PORTALE COPERNICUS

setwd("C:/Lab")

# AR - new library ncdf4 che permette di vedere i dati con estensione NC
#install.packages("ncdf4")

library(ncdf4)
library(raster)

# AR - brick porta diverse bande della riflettanza/ raster una singola banda con tutte le componenti

snowmay <- raster("c_gls_SCE500_202005180000_CEURO_MODIS_V1.0.1.nc")

cl <- colorRampPalette(c('darkblue','blue','light blue'))(100)
 
plot(snowmay, col=cl)

######  AR - import snow data #####
# AR - new wd

setwd("C:/Lab/snow")

# AR - da iol lApply, ci sono dei comandi per portare tutti i dati
# AR - put all files into the folder

# AR - nella nostra cartella abbiamo file tif
rlist=list.files(pattern=".tif", full.names=T)

# AR - save raster into list
# AR - con lappy che praticamente non fa altro che applicare una serie di comandi a tutti gli elementi, la funzione è raster, la lista è rlist
list_rast=lapply(rlist, raster)
EN <- stack(list_rast)
plot(EN)

snow.multitemp <- stack(rlist)
snow.multitemp

plot(snow.multitemp, col=cl)

# AR - il 2000 ed il 2010 sono dati simulati

# AR - facciamo il plot della prima e l'ultima -- zlim rappresenta il limmite delle bande (la c per i vettori)

par(mfrow=c(1,2))
plot(snow.multitemp$snow2000r, col=cl)
plot(snow.multitemp$snow2020r, col=cl)

# AR - - zlim rappresenta il limmite delle bande (la c per i vettori)

par(mfrow=c(1,2))
plot(snow.multitemp$snow2000r, col=cl,  zlim=c(0,250))
plot(snow.multitemp$snow2020r, col=cl, zlim=c(0,250))

# AR - andiamo a fare una differenza delle due immagini
diffsnow = snow.multitemp$snow2020r - snow.multitemp$snow2000r

cldiff <- colorRampPalette(c('blue', 'white', 'red'))(100)
plot(diffsnow, col=cldiff)

# AR - prediction 
# AR - go to IOL and download preiction.r
# AR - funzione source per caricare UN CODICE dall'esterno
source("prediction.r")

# AR - since the code need time, download pre... from iol
plot(predicted.snow.2025.norm, col=cl)

# AR - con la funz raster lo leghiamo al file scaricato nella cartella snow
predicted.snow.2025.norm <- raster("predicted.snow.2025.norm.tif")

plot(predicted.snow.2025.norm, col=cl)

##############################################
##############################################
##############################################

### 10. R CODE PATCHES 
    
# AR - CODICE R PER ANALISI DELLA FRAMMENTAZIONE DEGLI ECOSISTEMI

# AR -  R code Patches

#install.packages("raster")
library(raster)
#install.packages("igraph")
library(igraph)
#install.packages("ggplot2")
library(ggplot2)

# AR -  per entrare nella cartella di lavoro
setwd("C:/Lab") # windows

# AR -  per importare le due immagini
d1c <- raster("d1c.tif")
d2c <- raster("d2c.tif")

# plottare le due immagini 
par(mfrow=c(1,2))
cl <- colorRampPalette(c('black','green'))(100) #
plot(d1c,col=cl)
plot(d2c,col=cl)

# AR -  riclassificazione della prima immagine
# AR -  land cover 1= agriculture; land cover 2=forest
d1c.for <- reclassify(d1c, cbind(1, NA))

# AR -  plottare l'immagine riclassificata con l'immagine originale
par(mfrow=c(1,2))
cl <- colorRampPalette(c('black','green'))(100) #
plot(d1c,col=cl)
plot(d1c.for,col=cl)

dev.off()

# AR -  riclassificazione della seconda immagine
d2c.for <- reclassify(d2c, cbind(1, NA))

# AR -  plottare le due immagini riclassificate 
par(mfrow=c(1,2))
cl <- colorRampPalette(c('black','green'))(100) #
plot(d1c.for,col=cl)
plot(d2c.for,col=cl)

dev.off()

# AR -  funzione clump aggrage i pixels vicini per formare un'unica patche
d1c.for.patches <- clump(d1c.for)
d2c.for.patches <- clump(d2c.for)

# AR -  plottare le due immagini riclassificate 
par(mfrow=c(1,2))
cl <- colorRampPalette(c('black','green'))(100) #
plot(d1c.for.patches,col=cl)
plot(d2c.for.patches,col=cl)

# AR -  per salvare il raster nella cartella di lavoro
writeRaster(d1c.for.patches, "d1c.for.patches.tif")
writeRaster(d2c.for.patches, "d2c.for.patches.tif")

# AR - Exercise: plottare con un'altra color palette
clp <- colorRampPalette(c('dark blue','blue','green','orange','yellow','red'))(100) # 
par(mfrow=c(1,2))
plot(d1c.for.patches, col=clp)
plot(d2c.for.patches, col=clp)

#  AR - max patches d1 = 301
#  AR - max patches d2 = 1212

#  AR - analisi multitemporale del numero di patches
time <- c("Before deforestation","After deforestation")
npatches <- c(301,1212)

output <- data.frame(time,npatches)
attach(output)

ggplot(output, aes(x=time, y=npatches, color="red")) + geom_bar(stat="identity", fill="white")


##############################################
##############################################
##############################################

### 11. R code crop

#  AR - crop an image

setwd("C:/Lab")

library(raster)
library(ncdf4) #because we work with copernicus images

snow <- raster('c_gls_SCE500_202005180000_CEURO_MODIS_V1.0.1.nc')

cl <- colorRampPalette(c('darkblue','blue','lightblue'))(100)
plot(snow, col=cl)

#  AR - now we can zoom or crop
#  AR - we want that our extention is from 0 - 20 (long) and from 35- 50 (lat)

ext <- c(0,20,35,50)

#  AR - now we can use the function zoom(object, ext)
zoom(snow, ext=ext)


#  AR - crop function and create a new image
snowitaly <- crop(snow, ext)
plot(snowitaly, col=cl)


#  AR - try to make it manually with drawExtent    (in the IOL site there is the R_code_crop_zoom)
zoom(snow, ext=drawExtent())


##############################################
##############################################
##############################################

### 12. R_code_SDM

# AR - CODICE PER L'ANALISI DELLA SPECIESDISTRIBUTION MODELLING

# Species monitoring

setwd("C:/Lab")

# AR - check in the documentation
library(sdm)
library(raster) #predictors
library(rgdal) #species



## AR - species
# AR - with sdm there is a new folder "external/pecies.shp" where there is species data 
file <- system.file("external/species.shp", package="sdm")
species <- shapefile(file)

plot(species)
# AR - extent --> lat/long --> we are in spain
species

# AR - look at occurrence species -- values of specie: 1=species present 0=species not present
species$occurrence 

# AR - let's make a condition with [ --> species occurence might be egual 1 (condition with ==) and the final comma to finish the condition
plot(species[species$Occurrence == 1,],col='blue',pch=16)
points(species[species$Occurrence == 0,],col='red',pch=16)

# AR - environmental variables -- inside external also there are the predictors
path <- system.file("external", package="sdm")

# AR - ASCII file temperature,vegetation, elevation,precipitation
lst <- list.files(path=path,pattern='asc$',full.names = T)
lst

# AR - make a stack of these variables
preds <- stack(lst)

cl <- colorRampPalette(c('blue','orange','red','yellow')) (100)
plot(preds, col=cl)

# AR - ex Brachipodiuorum rupestre -- correlation with different variables
plot(preds$elevation, col=cl)
points(species[species$Occurrence == 1,], pch=16)

plot(preds$temperature, col=cl)
points(species[species$Occurrence == 1,], pch=16)

plot(preds$precipitation, col=cl)
points(species[species$Occurrence == 1,], pch=16)

plot(preds$vegetation, col=cl)
points(species[species$Occurrence == 1,], pch=16)


##### AR - put togethere all these data (preds - species)
# AR - CREATE A MODEL

d <- sdmData(train=species, predictors=preds)
d 
# n° species only one (brachipodiuorum) -- type presence-absence (but it may be abbundance, with percentual)

#combination different variables (y=a+bx) (dataset --> d, species and predictors) (methods == type file?)
m1 <- sdm(Occurrence ~ elevation + precipitation + temperature + vegetation, data=d, methods = "glm")
p1 <- predict(m1, newdata=preds)

plot(p1, col=cl)
points(species[species$Occurrence == 1,], pch=16)

s1 <- stack(preds, p1)
plot(s1, col=cl)

################################################################
################################################################
#################################################################


# EXAM PROJECT

# Here put your code


